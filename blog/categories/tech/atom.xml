<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tech | katsyoshiのめもみたいなもの]]></title>
  <link href="http://blog.katsyoshi.org/blog/categories/tech/atom.xml" rel="self"/>
  <link href="http://blog.katsyoshi.org/"/>
  <updated>2018-08-17T00:54:37+09:00</updated>
  <id>http://blog.katsyoshi.org/</id>
  <author>
    <name><![CDATA[katsyoshi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[wireguardをはじめました]]></title>
    <link href="http://blog.katsyoshi.org/blog/2018/08/17/wireguard-hajimemashita/"/>
    <updated>2018-08-17T00:38:12+09:00</updated>
    <id>http://blog.katsyoshi.org/blog/2018/08/17/wireguard-hajimemashita</id>
    <content type="html"><![CDATA[<p>title 通り、 <a href="https://www.wireguard.com/"><code>wiregaurd</code></a> を家と <a href="https://vps.sakura.ad.jp/">さくらのVPS</a> にあるサーバーを繋いでみました</p>

<h2>install</h2>

<p>導入は簡単で <code>gentoo</code> は公式にあるので</p>

<p><code>
sudo emerge wireguard
</code></p>

<p>だけで、 <code>ubuntu</code> の場合も<a href="https://www.wireguard.com/install/#packages">インストールガイド</a>があるため簡単にインストールできます</p>

<p><code>
sudo apt install software-properties-common
sudo add-apt-repository ppa:wireguard/wireguard
sudo apt-get update
sudo apt-get install wireguard
</code></p>

<h2>引込</h2>

<p>あとは<a href="https://speakerdeck.com/fadis/zuo-tuteli-jie-suruwireguard">非常にかんたん</a>で<a href="https://wiki.archlinux.jp/index.php/WireGuard">ここ</a>を適宜読み替えることで
接続できます。</p>

<h2>おわり</h2>

<p>あとは、再起動時に自動で接続するように変更する必要がありそうですがつながったし、おそいのでこれでおわり</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello, Itamae from docker!!]]></title>
    <link href="http://blog.katsyoshi.org/blog/2018/07/09/hello/"/>
    <updated>2018-07-09T22:54:12+09:00</updated>
    <id>http://blog.katsyoshi.org/blog/2018/07/09/hello</id>
    <content type="html"><![CDATA[<p><a href="https://itamae.kitchen/">Itamae</a> の plugin 書いててそろそろ test 欲しいなあとおもって2年くらいたちましたが、
ようやく <a href="https://www.docker.com/">Docker</a> 使って test 書きました。</p>

<h3>方向性</h3>

<p>ここでテストを実施するとして何に対しておこなうのかというのを考えましたが、E2Eのテストだけで良いだろうという方向でテストを書くようにしています。
VMを立てて実行することにはチョット大袈裟だろうということでもっと簡単に、楽にということで <code>docker</code> を選択しています。</p>

<p>itamae で E2E のテストなのでここでは <a href="https://serverspec.org/">serverspec</a> を利用してテストを行います。
E2E のテスト準備として <code>docker</code> 内で最初に目的のレシピを実施し、そのレシピが正しく動作しているかをテストしています。</p>

<h3>準備とテスト実施</h3>

<p>準備として以下の <code>gem</code> を追加しますが、 <a href="https://github.com/swipely/docker-api">docker-api.gem</a> の方はなくてもとくに問題ないです。
<code>serverspec</code> の対象バックエンドで <code>docker</code> が<a href="https://tsub.hatenablog.com/entry/2016/06/25/222508">指定できるようになります</a>が、 <code>docker</code> 内 (<code>docker run -t hoge bundle exec serverspec</code> など) で <code>serverspec</code> を実施すれば実行できますので、好みで追加しましょう。</p>

<p><code>
spec.add_development_dependency "docker-api"
spec.add_development_dependency "serverspec"
</code></p>

<p>次に <code>Dockerfile</code> を作成します。ここでは単純に必要な準備を実施、テストしたいディレクトリの追加、 <code>bundler</code> を利用して <code>gem</code> のインストールを実施してから、対象のディレクトリで <code>itamae</code> の <code>local</code> を指定して対象の <code>docker</code> にレシピ適用します。そのあと <code>docker run</code> や <code>serverspec</code> を実施することでテストをすることが可能となります。</p>

<p><code>
FROM ruby
RUN echo "gem: --no-rdoc --no-ri" &gt;&gt; /.gemrc
RUN gem install bundler
ADD . /app
WORKDIR /app
RUN bundle install
RUN bundle exec itamae local samples/recipe.rb
CMD bundle exec rake
</code></p>

<h3><a href="https://github.com/katsyoshi/itamae-plugin-resource-pip">itamae-plugin-resource-pip</a></h3>

<p><a href="https://github.com/katsyoshi/itamae-plugin-resource-pip">itamae-plugin-resource-pip</a> でできるようになってます。
とくに <a href="https://docker.io">docker.io</a> とかで公開していませんので、以下に例を</p>

<p><code>
cd /path/to/itamae-plugin-resource-pip
docker build -t katsyoshi/itamae-plugin-resource-pip .
docker run -t katsyoshi/itamae-plugin-resource-pip bundle exec rake
</code></p>

<h3>おわり</h3>

<p>これやろうと思って調べてたらみつからずに <code>Dockerfile</code> 書き終えて、<a href="https://travis-ci.org">travis</a> を追加しようとしたときに、<a href="https://twitter.com/sue445">@sue445</a> さんが<a href="https://sue445.hatenablog.com/entry/2018/05/01/115522">やってた</a>のをみつけてしまった。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RubyKaigi2018]]></title>
    <link href="http://blog.katsyoshi.org/blog/2018/06/03/rubykaigi2018/"/>
    <updated>2018-06-03T23:44:28+09:00</updated>
    <id>http://blog.katsyoshi.org/blog/2018/06/03/rubykaigi2018</id>
    <content type="html"><![CDATA[<p>RubyKaigi2018 に行ってきた</p>

<h2>1日目</h2>

<p>1日目は、 ずっと会場Aにいました。</p>

<ol>
<li>Matz: <a href="http://rubykaigi.org/2018/presentations/yukihiro_matz.html#may31">Keynote</a></li>
<li>Aaron Patterson: <a href="http://rubykaigi.org/2018/presentations/tenderlove.html#may31">Analyzing and Reducing Ruby Memory Usage</a></li>
<li>Kenta Murata, and Yusaku Hatanaka: <a href="http://rubykaigi.org/2018/presentations/mrkn.html#may31">Deep Learning Programming on Ruby</a></li>
<li>Bozhidar Batsov: <a href="http://rubykaigi.org/2018/presentations/bbatsov.html#may31">All About RuboCop</a></li>
<li>Naotoshi Seo: <a href="http://rubykaigi.org/2018/presentations/sonots.html#may31">Fast Numerical Computing and Deep Learning in Ruby with Cumo</a></li>
<li>Emma Haruka Iwao: <a href="http://rubykaigi.org/2018/presentations/Yuryu.html#may31">Exploring Internal Ruby Through C Extensions</a></li>
<li><a href="http://rubykaigi.org/2018/presentations/lt/">Lightning Talks</a></li>
</ol>


<p>この日、今年の RubyKaigi 2018 で最も楽しみにしてたのが <code>rubocop</code> の作者のトークで、彼のプロダクト(<code>rubocop</code>, <code>flycheck-ruby</code>)を利用してる身としては非常に楽しみでした。
DLと数値計算のやつは進捗が聞けてよかったっていうのとDeep Learningに関していうと難しいのかなあという感想が…
Haruka さんのやつは、やっぱり今の実装十分に速いってのがわかって、これ以上速くするには非常に大変だなってのがよかったですね。
LTはどれもよくて <code>rib</code> も面白いし、 csvの高速化の話が特に好きでした。</p>

<h2>2日目</h2>

<p>2日目もほとんどA会場できいていたのと、GitHubの電源スペースにいました。</p>

<ol>
<li>Kouhei Sutou: <a href="http://rubykaigi.org/2018/presentations/ktou.html#jun01">My way with Ruby</a></li>
<li>Kouichi Sasada: <a href="http://rubykaigi.org/2018/presentations/ko1.html#jun01">Guild Prototype</a></li>
<li>Yuichiro Kaneko: <a href="http://rubykaigi.org/2018/presentations/spikeolaf.html#jun01">RNode with code positions</a></li>
<li>Yusuke Endo: <a href="http://rubykaigi.org/2018/presentations/mametter.html#jun01">Type Profiler: An analysis to guess type signatures</a></li>
<li><a href="http://rubykaigi.org/2018/presentations/rubylangorg.html#jun01">Ruby Commiters vs. the World</a></li>
</ol>


<p>この日のトークは特に楽しみにしていたのはなかったのですが、ここ最近毎年聞いていた <a href="http://rubykaigi.org/2018/presentations/v0dro.html#jun01">@v0dro</a> の発表を聞いていなかった。
金子さんの発表がわりとたのしく聞けて、「あーやっぱり型のはなしは興味ないな」って感じで遠藤さんの発表聞いてました。
この日の懇親会で飲みすぎた。</p>

<h2>3日目</h2>

<p>3日目はパフォーマンス改善を中心として聞いてました。</p>

<ol>
<li>Benoit Daloze: <a href="http://rubykaigi.org/2018/presentations/eregontp.html#jun02">Parallel and Thread-Safe Ruby at High-Speed with TruffleRuby</a></li>
<li>Takashi Kokubun: <a href="http://rubykaigi.org/2018/presentations/k0kubun.html#jun02">The Method JIT Compiler for Ruby 2.6</a></li>
<li>Takeshi Watanabe: <a href="http://rubykaigi.org/2018/presentations/take-cheeze.html#jun02">LuaJIT as a Ruby backend.</a></li>
<li>Prasun Anand: <a href="http://rubykaigi.org/2018/presentations/prasun_anand.html#jun02">High Performance GPU computing with Ruby</a></li>
<li>Vladimir Makarov: <a href="http://rubykaigi.org/2018/presentations/vnmakarov.html#jun02">Three Ruby performance projects</a></li>
<li><a href="http://rubykaigi.org/2018/presentations/tric.html#jun02">TRICK 2018 (FINAL)</a></li>
</ol>


<p>TuffleRubyとはやくてとてもよさそう。
国分さん、Vladimirの話はいつもどおりで安心した。</p>

<p>TRICK、どうしてこんなプログラムが思いつくのかさっぱりわからんがとにかく凄い以上の感想がうかんでこない。</p>

<h2>おわり</h2>

<p>RubyKaigi 2018に行ってきてたいへんたのしいイベントでした。</p>

<p>(型のはなしはやはり興味がないというかまだまだ理解が浅いのでTaPL読むべきだな)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[API キーが凍結されてら]]></title>
    <link href="http://blog.katsyoshi.org/blog/2018/05/06/teokure/"/>
    <updated>2018-05-06T23:33:23+09:00</updated>
    <id>http://blog.katsyoshi.org/blog/2018/05/06/teokure</id>
    <content type="html"><![CDATA[<p>mikutter の <a href="http://mikutter.hatenablog.com/entry/2018/05/05/164014">Twitter API キーが凍結された</a> ようです。</p>

<h2>回避方法</h2>

<p>とりあず、twitter の <a href="https://developer.twitter.com/en.html">開発者ページ</a> から API キーを生成してください。
あとは以下の様に編集してください</p>

<p>```diff
diff &mdash;git a/Gemfile b/Gemfile
index 0a88a191..cb48cd4f 100644
&mdash;&ndash; a/Gemfile
+++ b/Gemfile
@@ -21,6 +21,7 @@ group :default do
   gem &lsquo;pluggaloid&rsquo;, &lsquo;>= 1.1.1&rsquo;, &lsquo;&lt; 2.0&rsquo;
   gem &lsquo;delayer-deferred&rsquo;, &lsquo;>= 2.0&rsquo;, &lsquo;&lt; 3.0&rsquo;
   gem &lsquo;twitter-text&rsquo;, &lsquo;>= 2.1.0&rsquo;
+  gem &lsquo;dotenv&rsquo;
 end</p>

<p> group :test do
diff &mdash;git a/core/config.rb b/core/config.rb
index 6e3d95ba..455e3083 100644
&mdash;&ndash; a/core/config.rb
+++ b/core/config.rb
@@ -14,8 +14,8 @@ module CHIConfig
   ACRO = &ldquo;mikutter&rdquo;</p>

<p>   # 下の２行は馬鹿にしか見えない
&ndash;  TWITTER_CONSUMER_KEY = &ldquo;AmDS1hCCXWstbss5624kVw&rdquo;
&ndash;  TWITTER_CONSUMER_SECRET = &ldquo;KOPOooopg9Scu7gJUBHBWjwkXz9xgPJxnhnhO55VQ&rdquo;
+  TWITTER_CONSUMER_KEY = ENV[&ldquo;TWITTER_CONSUMER_KEY&rdquo;]
+  TWITTER_CONSUMER_SECRET = ENV[&ldquo;TWITTER_SECRET_KEY&rdquo;]
   TWITTER_AUTHENTICATE_REVISION = 1</p>

<p>   # pidファイル
diff &mdash;git a/mikutter.rb b/mikutter.rb
index da302ca1..94025817 100755
&mdash;&ndash; a/mikutter.rb
+++ b/mikutter.rb
@@ -32,6 +32,8 @@ require &lsquo;benchmark&rsquo;
 require &lsquo;webrick&rsquo;
 require &lsquo;thread&rsquo;
 require &lsquo;fileutils&rsquo;
+require &lsquo;dotenv&rsquo;
+Dotenv.load(&ldquo;.env&rdquo;)</p>

<p> require_relative &lsquo;core/utils&rsquo;
```</p>

<p>あとは環境変数<code>TWITTER_CONSUMER_KEY</code> と <code>TWITTER_SECRET_KEY</code> を設定してあげると起動できるようになります</p>

<h3>dotenv</h3>

<p>環境変数を指定して毎回起動したくない、とか <code>.bashrc</code> に書きたくない、とかある場合は
<a href="https://github.com/bkeepers/dotenv"><code>dotenv.gem</code> </a> を使うことで良いかんじに読みとってくれるようになります。
つかいかたは <code>Dotenv.load(file_name)</code> で <code>file_name</code> にあるファイルのなかに環境変数を書けばよいです。</p>

<h2>おわり</h2>

<p>おわり。
別に <code>dotenv.gem</code> いらんなこれ</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NLP100 Knock Section IV]]></title>
    <link href="http://blog.katsyoshi.org/blog/2018/02/26/nlp-100-section-4/"/>
    <updated>2018-02-26T23:45:52+09:00</updated>
    <id>http://blog.katsyoshi.org/blog/2018/02/26/nlp-100-section-4</id>
    <content type="html"><![CDATA[<p>NLP100本ノック第4節おわりましたのでまとめます</p>

<h2><a href="http://www.cl.ecei.tohoku.ac.jp/nlp100/#ch4">第4章 形態素解析</a></h2>

<p>形態素解析やからむずいやろとおもってた</p>

<h3>準備</h3>

<p>この章では、形態素解析済ファイルを作成する必要がありますが、毎回対象ファイルをダウンロード、解析して解いています。
ここではいつもどおり <code>HashMap</code> を利用するため <code>ANALYZED_MECAB_KEYS</code> を作成してこれをキーにします。
またよく利用する品詞を <code>enum</code> で定義しておき、変換関数 <code>inspect</code> を作成します。</p>

<p>```rust
const ANALYZED_MECAB_KEYS: [&str; 9] = [&ldquo;pos&rdquo;, &ldquo;pos1&rdquo;, &ldquo;pos2&rdquo;, &ldquo;pos3&rdquo;, &ldquo;a&rdquo;, &ldquo;b&rdquo;, &ldquo;base&rdquo;, &ldquo;read&rdquo;, &ldquo;speech&rdquo;];
enum PartOfSpeech {</p>

<pre><code>VERB,
NOUN,
PARTICLE,
</code></pre>

<p>}</p>

<p>use PartOfSpeech::*;</p>

<p>fn inspect(val: PartOfSpeech) &ndash;> String {</p>

<pre><code>match val {
    VERB =&gt; "動詞",
    NOUN =&gt; "名詞",
    PARTICLE =&gt; "助詞",
}.to_string()
</code></pre>

<p>}
```</p>

<h3><a href="http://www.cl.ecei.tohoku.ac.jp/nlp100/#sec30">30. 形態素解析結果の読み込み</a></h3>

<p><code>Map</code> を使えと指定があるので素直に利用します</p>

<p>```rust
fn feature(node: &amp;Node) &ndash;> HashMap&lt;String, String> {</p>

<pre><code>let mut h: HashMap&lt;String, String&gt; = HashMap::new();
let surface: String = (&amp;(node.surface)[..node.length as usize]).to_string();
h.insert("surface".to_string(), surface);
let values: Vec&lt;String&gt; = node.feature.split(",").map(|m| m.to_string()).collect();
for (a, b) in ANALYZED_MECAB_KEYS.iter().zip(values.iter()) {
    h.insert(a.to_string(), b.to_string());
}
h
</code></pre>

<p>}</p>

<p>fn main() {</p>

<pre><code>let url = "http://www.cl.ecei.tohoku.ac.jp/nlp100/data/neko.txt".to_string();
let neco: Vec&lt;String&gt; = NLP100::get(url).split("\n").filter(|f| f.ne(&amp;"")).map(|m| m.to_string()).collect();
let mut morph = Vec::new();

for line in neco {
    let mut tagger: Tagger = mecab::Tagger::new("");
    let nodes: Node = tagger.parse_to_node(line);

    let mut mecabu: Vec&lt;HashMap&lt;String, String&gt;&gt; = Vec::new();
    for node in nodes.iter_next() {
        match node.stat as i32 {
            mecab::MECAB_BOS_NODE =&gt; (),
            mecab::MECAB_EOS_NODE =&gt; (),
            _ =&gt; {
                mecabu.push(feature(&amp;node));
            }
        }
    }
    morph.push(mecabu);
}
for morph in morphs {
    for mecab in morph {
        println!("{}", format!("surface: {}, base: {}, pos: {}, pos1: {}", mecab["surface"], mecab["base"], mecab["pos"], mecab["pos1"]));
    }
    println!("");
}
</code></pre>

<p>}
```</p>

<h3><a href="http://www.cl.ecei.tohoku.ac.jp/nlp100/#sec31">31. 動詞</a></h3>

<p>動詞だけ抽出するので以下のコードで抽出し、表層形(<code>"surface"</code>)を取得する</p>

<p>```rust
fn verb(nodes: Vec&lt;HashMap&lt;String, String>>) &ndash;> Vec&lt;HashMap&lt;String, String>> {</p>

<pre><code>nodes.iter().filter(|m| m["pos"] == inspect(VERB)).map(|hm| hm.clone()).collect()
</code></pre>

<p>}
```</p>

<h3><a href="http://www.cl.ecei.tohoku.ac.jp/nlp100/#sec32">32. 動詞の原形</a></h3>

<p>動詞だけ抽出するので上記のコードで抽出し、原形(<code>"base"</code>)を取得する</p>

<h3><a href="http://www.cl.ecei.tohoku.ac.jp/nlp100/#sec33">33. サ変名詞</a></h3>

<p>サ変接続を抽出</p>

<p>```rust
fn sa_noun(nodes: Vec&lt;HashMap&lt;String, String>>) &ndash;> Vec&lt;HashMap&lt;String, String>>{</p>

<pre><code>noun(nodes).iter().filter(|node| node["pos1"] == "サ変接続").map(|hm| hm.clone()).collect()
</code></pre>

<p>}
```</p>

<h3><a href="http://www.cl.ecei.tohoku.ac.jp/nlp100/#sec34">34. 「AのB」</a></h3>

<p>「の」を挾んでいる名詞を抽出</p>

<p>```rust
fn between_noun(node: &amp;Node) &ndash;> Option<String> {</p>

<pre><code>let mecab = feature(node);
if mecab["surface"] == "の" &amp;&amp; mecab["pos"] == inspect(PARTICLE) &amp;&amp; mecab["pos1"] == "連体化" {
    let prev = feature(&amp;node.prev().unwrap());
    let next = feature(&amp;node.next().unwrap());

    Some(format!("{}{}{}", &amp;prev["surface"], &amp;mecab["surface"], &amp;next["surface"]))
} else {
    None
}
</code></pre>

<p>}
```</p>

<h3><a href="http://www.cl.ecei.tohoku.ac.jp/nlp100/#sec35">35. 名詞の連接</a></h3>

<p>連続した名詞を抽出するが、<code>mecab</code> でうまく関数化できなかったので割愛(あとでうかんだら追記)します。</p>

<h3><a href="http://www.cl.ecei.tohoku.ac.jp/nlp100/#sec36">36. 単語の出現頻度</a></h3>

<p>単純に頻度をまとめ、 <code>sort</code> するとよい</p>

<p>```rust
fn word_histgram(nodes: Vec&lt;HashMap&lt;String, String>>) &ndash;> HashMap&lt;String, u64> {</p>

<pre><code>let mut results: HashMap&lt;String, u64&gt; = HashMap::new();
for node in nodes {
    let base = &amp;node["base"];
    *results.entry(base.to_string()).or_insert(0) += 1;
}
results
</code></pre>

<p>}
```</p>

<h3><a href="http://www.cl.ecei.tohoku.ac.jp/nlp100/#sec37">37. 頻度上位10語</a></h3>

<p>上記の結果より <code>.take(10)</code> するだけです。</p>

<h3><a href="http://www.cl.ecei.tohoku.ac.jp/nlp100/#sec38">38. ヒストグラム</a></h3>

<p>37 と違いがわからずおわり。</p>

<h3><a href="http://www.cl.ecei.tohoku.ac.jp/nlp100/#sec39">39. Zipfの法則</a></h3>

<p>単純に両対数グラフ化でおわり。</p>

<h2>おわり</h2>

<p>おわり</p>
]]></content>
  </entry>
  
</feed>
